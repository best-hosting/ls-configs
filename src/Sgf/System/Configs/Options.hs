{-# LANGUAGE OverloadedStrings  #-}
{-# LANGUAGE RankNTypes             #-}
{-# LANGUAGE ScopedTypeVariables    #-}

module Sgf.System.Configs.Options
    ( Config (..)
    , excludeFiles
    , opts
    )
  where

import Prelude hiding (FilePath)
import Data.Maybe
import Data.Monoid
import Data.String
import Control.Applicative
import Control.Monad.Reader
import qualified Options.Applicative as Opt
import qualified Data.Attoparsec.Text as A
import qualified Data.Text as T
import Turtle.Prelude
import Turtle.Shell
import Turtle.Line
import Filesystem.Path.CurrentOS (FilePath, fromText)
import Control.Monad.Except
import Control.Foldl (Fold (..))

import Sgf.Control.Lens
import Sgf.System.Configs.Types
import Sgf.System.Configs.Parser
import Sgf.System.Configs.Common
import Sgf.System.Configs.System


-- | Program own config.
data Config         = Config
                        { dpkgOutput        :: Shell (Either Line Line)
                        , dbFile            :: Maybe FilePath
                        , etcPath           :: FilePath
                        , targetPath        :: Maybe FilePath
                        , hashesList        :: CInfo -> [Md5]
                        , hashFilter        :: (CInfo -> [Md5]) -> CInfo -> Bool
                        , fileTypeFilter    :: CInfo -> Bool
                        , fileFilter        :: Maybe FilePath
                        , packageFilter     :: Package -> Bool
                        , targetFilter      :: CInfo -> Bool
                        }

-- | Options related to target directory.
targetFilterOpts :: Opt.Parser (CInfo -> Bool)
targetFilterOpts    =
        Opt.flag' (cmpBy (==))
            (  Opt.long "target-equal"
            <> Opt.help
                    ("Show source files, which are the same in target."))
    <|> Opt.flag' (fromMaybe False <$> cmpBy (liftA2 (/=)))
            (  Opt.long "target-differ"
            <> Opt.help
                    ("Show source files differing from target ones."))
    <|> Opt.flag' (isNothing . viewA targetFileHash)
            (  Opt.long "target-missed"
            <> Opt.help
                    ("Show source files missed in target."))
    <|> pure (fromMaybe True <$> cmpBy (liftA2 (/=)))
  where
    cmpBy :: (Maybe (Hash Computed) -> Maybe (Hash Computed) -> b)
           -> CInfo -> b
    cmpBy eq        = eq <$> viewA fileHash <*> viewA targetFileHash

-- | Options for generating list of hashes to filter from.
hashesListOpts :: Opt.Parser (CInfo -> [Md5])
hashesListOpts      = fromMaybe ((++) <$> allStored <*> allObsolete)
    . foldr mappend mempty
        <$> (Opt.flag Nothing (Just allStored)
                (   Opt.long "stored"
                <>  Opt.help
                      ("Search among files with not an obsolete hashes"
                    ++ " (may be combined with '--obsolete')."))
        <:> Opt.flag Nothing (Just allObsolete)
                (   Opt.long "obsolete"
                <>  Opt.help
                       ("Search among files with obsolete hashes"
                     ++ " (may be combined with '--stored')."))
        <:> pure [])

-- | Options for filtering list generated by 'hashesListOpts'.
hashFilterOpts :: Opt.Parser ((CInfo -> [Md5]) -> CInfo -> Bool)
hashFilterOpts      =
        Opt.flag' (viewAmaybe computed `neq`)
            (  Opt.long "changed"
            <> Opt.help
                      ("Show changed configs instead"
                    ++ " (not matching to selected hashes). "
                    ++ " By default show matched configs."))
    <|> Opt.flag' (\f -> null . f)
            (   Opt.long "other"
            <>  Opt.help
                    "Show files, which does not have hashes in 'dpkg' db.")
    <|> Opt.flag' (const (isNothing . viewAmaybe computed))
            (   Opt.long "errors-read"
            <>  Opt.help
                    "Show files, which can't be read.")
    <|> Opt.flag' (const (     (== mempty) . viewA package
                          <&&> not . null . viewA loadedHashes))
            (   Opt.long "errors-orphaned"
            <>  Opt.help
                    "Show files does not belonging to any package.")
    <|> Opt.flag' (const (isJust . viewAmaybe computed))
            (   Opt.long "all"
            <>  Opt.help
                    ("Do not filter files by computed hash,"
                    ++ " but still require, that i _can_ compute hash."))
    <|> pure (viewAmaybe computed `eq`)
  where
    -- | Generalize an `elem`. Empty list is a failure (default value is
    -- returned). Default value is 'False'.
    eq :: Eq a =>
             (CInfo -> Maybe a) -- ^ Obtain an element.
          -> (CInfo -> [a])     -- ^ Obtain a list to match with.
          -> CInfo -> Bool
    eq mh mhs x    = fromMaybe False . flip runReaderT x $ do
        h  <- ReaderT mh
        hs <- ReaderT (maybeList <$> mhs)
        return (h `elem` hs)
    -- | Generalize a `notElem`. Empty list is a failure (default value is
    -- returned). Default value is 'False'.
    neq :: Eq a =>
             (CInfo -> Maybe a) -- ^ Obtain an element.
          -> (CInfo -> [a])     -- ^ Obtain a list to match with.
          -> CInfo -> Bool
    neq mh mhs x    = fromMaybe False . flip runReaderT x $ do
        h  <- ReaderT mh
        hs <- ReaderT (maybeList <$> mhs)
        return (h `notElem` hs)

-- | Options for filtering by filetype.
fileTypeOpts :: Opt.Parser (CInfo -> Bool)
fileTypeOpts        = maybe (const True) (fmap getAny) . foldr mappend mempty
    <$> Opt.flag Nothing (Just $ Any <$> isFileInfo)
            (  Opt.long "files"
            <> Opt.help
                "Only search among files (may be combined '--symlinks').")
    <:> Opt.flag Nothing (Just $ Any <$> isSymLinkInfo)
            (  Opt.long "symlinks"
            <> Opt.help
                  ("Only search among symbolic links"
                ++ " (may be combined '--files')."))
    <:> pure []

packageOpts :: Opt.Parser (Package -> Bool)
packageOpts         = liftA2 (&&)
    <$> (pkgF    <$> ((some $ Opt.option readParser
            (  Opt.long "package"
            <> Opt.metavar "PACKAGE"
            <> Opt.help ("Filter `dpkg-query` output by package name "
                         ++ " (exact match only).")))
        <|> pure [A.takeText]))   -- This 'pure' is at 'Opt.Parser' level.
    <*> (statusF <$> ((some $ Opt.option readParser
            (  Opt.long "status"
            <> Opt.metavar "STATUS"
            <> Opt.help ("Filter `dpkg-query` output by package install status"
                         ++ " (exact match only).")))
        <|> pure [A.takeText]))    -- This 'pure' is at 'Opt.Parser' level.
  where
    readParser :: Opt.ReadM (A.Parser T.Text)
    readParser      = Opt.eitherReader (return . A.string . T.pack)
    viewM :: Monoid b => LensA a (Maybe b) -> a -> b
    viewM l         = fromMaybe mempty . viewA l
    pkgF :: [A.Parser T.Text] -> Package -> Bool
    pkgF ps         = byField (viewM pkgName)   (A.choice ps <* A.endOfInput)
    statusF :: [A.Parser T.Text] -> Package -> Bool
    statusF ps      = byField (viewM pkgStatus) (A.choice ps <* A.endOfInput)

opts :: Opt.Parser Config
opts                = Config
    <$> (   Opt.flag' (Right <$> stdin)
                (  Opt.long "stdin"
                <> Opt.help "Read `dpkg-query` output from stdin.")
            <|> fmap Right . input . fromString <$> Opt.strOption
                (  Opt.long "file"
                <> Opt.metavar "FILE"
                <> Opt.help "Read `dpkg-query` output from file.")
            <|> pure systemConfsWithPkg
        )
    <*> (   Opt.option (Opt.eitherReader readFilePath)
                (  Opt.long "db"
                <> Opt.value Nothing
                <> Opt.metavar "FILE"
                <> Opt.help "Store db to file.")
        )
    <*> (fromMaybe "/etc/"
            <$> Opt.option (Opt.eitherReader readFilePath)
                (  Opt.long "source"
                <> Opt.value Nothing
                <> Opt.metavar "DIR"
                <> Opt.help "Path to directory, where `/etc` is.")
        )
    <*> (Opt.option (Opt.eitherReader readFilePath)
            (  Opt.long "target"
            <> Opt.value Nothing
            <> Opt.metavar "DIR"
            <> Opt.help ("Directory to compare source files with.")))
    <*> hashesListOpts
    <*> hashFilterOpts
    <*> fileTypeOpts
    <*> (Opt.option (Opt.eitherReader readFilePath)
            (  Opt.long "filter"
            <> Opt.value Nothing
            <> Opt.metavar "FILE"
            <> Opt.help
                (   "Exclude filter file."
                ++  " Pathes must match *exactly* "
                ++  " and must be relative to source path.")))
    <*> packageOpts
    <*> targetFilterOpts
  where
    readFilePath :: String -> Either String (Maybe FilePath)
    readFilePath          = Right . Just . fromText . fromString

-- | Make a predicate from a list of excluded files read from a file.
excludeFiles :: Maybe FilePath -> P (CInfo -> Bool)
excludeFiles mf     = flip catchError def $ do
    f <- liftMaybe mf
    b <- testfile f
    if (not b)
      then throwError "Exclude file does not exist."
      else fold (readExcludes f) (Fold mappend mempty (fmap getAll))
  where
    def :: MonadError e m => e -> m (CInfo -> Bool)
    def _           = return (const True)
    -- | Read file with excludes and build predicates from read filenames.
    readExcludes :: FilePath -> Shell (CInfo -> All)
    readExcludes f  = do
        x <- fromText . lineToText <$> input f
        return (All <$> (/= x) . viewA filePath)

